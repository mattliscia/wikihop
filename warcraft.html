<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Warcraft Wiki Game - Navigate from Start to Target | Warcraft</title>

<!-- Meta Description -->
<meta name="description" content="Play the Warcraft Wiki Game! Navigate from one Warcraft wiki page to another using only internal links. Challenge your friends and see who can reach the target in fewer clicks." />

<!-- Keywords -->
<meta name="keywords" content="Warcraft, World of Warcraft, WoW, wiki game, navigation game, Warcraft wiki, gaming, wiki challenge, browser game" />

<!-- Author -->
<meta name="author" content="WikiHop" />

<!-- Favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png">
<link rel="manifest" href="images/favicon/site.webmanifest">
<link rel="shortcut icon" href="images/favicon/favicon.ico">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://wikihop.net/warcraft" />
<meta property="og:title" content="Warcraft Wiki Game - Navigate from Start to Target" />
<meta property="og:description" content="Play the Warcraft Wiki Game! Navigate from one Warcraft wiki page to another using only internal links. Challenge your friends and see who can reach the target in fewer clicks." />
<meta property="og:image" content="https://wikihop.net/images/logo.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
<meta property="og:site_name" content="WikiHop" />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content="https://wikihop.net/warcraft" />
<meta property="twitter:title" content="Warcraft Wiki Game - Navigate from Start to Target" />
<meta property="twitter:description" content="Play the Warcraft Wiki Game! Navigate from one Warcraft wiki page to another using only internal links. Challenge your friends and see who can reach the target in fewer clicks." />
<meta property="twitter:image" content="https://wikihop.net/images/logo.png" />

<!-- Additional Meta Tags -->
<meta name="robots" content="index, follow" />
<meta name="language" content="English" />
<meta name="revisit-after" content="7 days" />
<meta name="theme-color" content="#1e293b" />

<!-- Preconnect to external domains -->
<link rel="preconnect" href="https://cdn.tailwindcss.com">
<link rel="preconnect" href="https://warcraft.wiki.gg">

<script src="https://cdn.tailwindcss.com"></script>
<script src="header.js"></script>
</head>
<body class="bg-slate-900 text-slate-100">


  <main class="p-4">
    <div class="flex gap-4 max-w-7xl mx-auto">
      <!-- Main Content Area (75%) -->
      <div class="flex-1">
        <div class="rounded-xl overflow-hidden shadow ring-1 ring-slate-800">
          <!-- No allow-same-origin needed; fewer warnings, safer. -->
          <iframe id="wikiFrame" class="w-full h-[80vh] bg-white" sandbox="allow-scripts"></iframe>
        </div>
        <p class="mt-2 text-xs text-slate-400">
          Content Â© Warcraft Wiki contributors (CC BY-SA).
        </p>
      </div>
      
      <!-- Sidebar (25%) -->
      <div class="w-80 flex-shrink-0">
        <!-- Game Stats -->
        <div class="bg-slate-800 rounded-lg border border-slate-700 p-4 mb-4">
          <div class="flex justify-between items-center mb-3">
            <h3 class="hidden text-lg font-semibold text-yellow-400">Game Stats</h3>
            <div class="flex gap-2">
              <button id="btnCopyChallenge" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-sm">Copy Challenge</button>
              <button id="btnNew" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-sm">New round</button>
            </div>
          </div>
          <div class="grid grid-cols-2 gap-3 text-sm">
            <div class="bg-slate-700 rounded p-2">
              <div class="text-slate-400">Clicks</div>
              <div class="font-bold text-yellow-400" id="clicks">0</div>
            </div>
            <div class="bg-slate-700 rounded p-2">
              <div class="text-slate-400">Time</div>
              <div class="font-bold text-purple-400" id="timer">0:00</div>
            </div>
          </div>
        </div>
        
        <!-- Destination Info -->
        <div id="destinationInfo" class="bg-slate-800 rounded-lg border border-slate-700 p-4 mb-4">
          <h2 class="text-xl font-bold flex-1">Target Page:</h2>
          <div class="flex items-center gap-3 mb-3">
            <div id="destImage" class="hidden">
              <img id="destImageSrc" class="w-16 h-16 object-contain rounded-lg" alt="Destination image">
            </div>
            <h2 class="text-2xl font-bold text-green-400 flex-1" id="destTitle"></h2>
            
          </div>
          <p id="destDescription" class="text-slate-300 text-sm leading-relaxed">
            Click "New round" to start a game and see your destination here.
          </p>
        </div>
        
        <!-- Navigation History -->
        <div class="bg-slate-800 rounded-lg border border-slate-700 p-4">
          <h3 class="text-lg font-semibold text-blue-400 mb-3">Your Path</h3>
          <div id="pathHistory" class="space-y-2 max-h-96 overflow-y-auto">
            <p class="text-slate-400 text-sm">No pages visited yet.</p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Win Modal -->
  <div id="winModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" onclick="hideWinModal()">
    <div class="bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl" onclick="event.stopPropagation()">
      <div class="text-center">
        <h2 class="text-2xl font-bold text-yellow-400 mb-4">You Won!</h2>
        <div class="flex justify-between items-center mb-6">
          <div class="text-left">
            <h3 class="text-sm font-semibold text-slate-300 mb-2">Your Path:</h3>
            <div id="winPathSteps" class="text-xs text-slate-400 space-y-1"></div>
          </div>
          <div class="text-right self-start">
            <p class="text-slate-300"><span id="winClicks" class="font-bold text-yellow-400"></span> clicks</p>
            <p class="text-slate-300">Time: <span id="winTime" class="font-bold text-purple-400"></span></p>
          </div>
        </div>

        <div class="mb-6 text-center">
          <h3 class="text-lg font-semibold text-slate-300 mb-2">Challenge Your Friends!</h3>
          <p class="text-sm text-slate-400">Share this exact challenge and see if your friends can beat your score.</p>
        </div>
        
        <div class="space-y-3">
          <button id="btnCopyLink" class="w-full px-4 py-2 bg-slate-600 hover:bg-slate-700 rounded-lg text-white font-semibold">
            Copy Challenge Link
          </button>
          <button id="btnShareTwitter" class="w-full px-4 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg text-white font-semibold">
            Share on Twitter/X
          </button>
          
          <button id="btnCloseWin" class="w-full px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white font-semibold">
            New Round
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Get current wiki configuration
  const API = 'https://warcraft.wiki.gg/api.php';
  const SITE = 'https://warcraft.wiki.gg';



  let startTitle=null, targetTitle=null, currentTitle=null;
  let clickCount=0, startTimeMs=0, timerInterval=null, path=[];
  
  // URL parameter handling
  function getUrlParams() {
    const params = new URLSearchParams(window.location.search);
    return {
      start: params.get('start'),
      target: params.get('target')
    };
  }
  
  function setUrlParams(start, target) {
    const url = new URL(window.location);
    url.searchParams.set('start', start);
    url.searchParams.set('target', target);
    window.history.replaceState({}, '', url);
  }
  
  function clearUrlParams() {
    const url = new URL(window.location);
    url.searchParams.delete('start');
    url.searchParams.delete('target');
    window.history.replaceState({}, '', url);
  }

  function fmtTime(ms){ const s=Math.floor(ms/1000), m=Math.floor(s/60); return `${m}:${String(s%60).padStart(2,'0')}`; }
  function startTimer(){ stopTimer(); startTimeMs=Date.now(); timerInterval=setInterval(()=>{document.getElementById('timer').textContent=fmtTime(Date.now()-startTimeMs)},250); }
  function stopTimer(){ if(timerInterval) clearInterval(timerInterval); timerInterval=null; }
  async function j(url){ const r=await fetch(url); if(!r.ok) throw new Error(r.status); return r.json(); }
  async function randTitle(){ const d=await j(`${API}?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*`); return d.query.random[0].title; }
  
  // Check if a title is too niche or problematic
  function isGoodTitle(title) {
    // Skip disambiguation pages
    if (title.includes('(disambiguation)') || title.includes('(Disambiguation)')) {
      return false;
    }

    if (title.toLowerCase().includes('version')) {
      return false;
    }
    
    // Skip transcript pages
    if (title.toLowerCase().includes('transcript')) {
      return false;
    }
    
    // Skip money making guide pages
    if (title.toLowerCase().includes('money making guide')) {
      return false;
    }
    
    // Skip any date/year patterns
    if (/\d{4}/.test(title)) {
      return false;
    }
    
    // Skip non-English language pages
    const languagePatterns = [
      /^[A-Za-z]+:/,  // Language prefixes like "Spanish:", "French:", etc.
      /\/[A-Za-z]{2}$/,  // Language suffixes like "/es", "/fr", "/de"
      /\([A-Za-z]{2}\)$/,  // Language codes in parentheses like "(es)", "(fr)"
      /^[A-Za-z]{2}\//,  // Language codes at start like "es/", "fr/"
      /\/[A-Za-z]{2}\//,  // Language codes in path like "/es/", "/fr/"
    ];
    
    for (const pattern of languagePatterns) {
      if (pattern.test(title)) {
        console.log('Filtered out non-English page:', title);
        return false;
      }
    }
    

    
    return true;
  }
  async function norm(t){ const d=await j(`${API}?action=query&redirects=1&titles=${encodeURIComponent(t)}&format=json&origin=*`); const id=Object.keys(d.query.pages)[0]; return d.query.pages[id].title; }
  
  // Update path history display
  function updatePathHistory() {
    const pathHistory = document.getElementById('pathHistory');
    if (path.length === 0) {
      pathHistory.innerHTML = '<p class="text-slate-400 text-sm">No pages visited yet.</p>';
      return;
    }
    
    pathHistory.innerHTML = path.map((title, index) => {
      const isCurrent = index === path.length - 1;
      const isStart = index === 0;
      const isTarget = title === targetTitle;
      
      let bgClass = 'bg-slate-700';
      let textClass = 'text-slate-300';
      
      if (isCurrent) {
        bgClass = 'bg-blue-600';
        textClass = 'text-white';
      } else if (isStart) {
        bgClass = 'bg-green-600';
        textClass = 'text-white';
      } else if (isTarget) {
        bgClass = 'bg-yellow-600';
        textClass = 'text-white';
      }
      
      return `
        <button onclick="goToPage(${index})" 
                class="w-full text-left p-2 rounded ${bgClass} ${textClass} hover:opacity-80 transition-opacity text-sm">
          ${index + 1}. ${title}
        </button>
      `;
    }).join('');
  }
  
  // Navigate to a specific page in history
  function goToPage(index) {
    if (index >= 0 && index < path.length) {
      // Render the selected page without modifying path or click count
      renderPage(path[index]);
      updatePathHistory();
    }
  }
  
  // Fetch target preview with image
  // Fetch target preview with image
  async function fetchTargetPreview(title) {
    try {
      // Fetch page content
      const url = `${API}?action=parse&format=json&formatversion=2&redirects=1` +
                  `&page=${encodeURIComponent(title)}&prop=text|images&section=0&origin=*`;
      const data = await j(url);
      
      // Extract first paragraph from the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = data.parse.text;
      
      // Update destination title (always set this)
      document.getElementById('destTitle').textContent = title;
      
      // Find the first paragraph that's not inside an infobox
      const allParagraphs = tempDiv.querySelectorAll('.mw-parser-output p');
      let firstP = null;
      
      for (const p of allParagraphs) {
        // Check if this paragraph is inside an infobox
        const isInInfobox = p.closest('.infobox') !== null;
        // Make sure paragraph has non-empty text content
        const text = p.textContent.trim();
        if (!isInInfobox && text.length > 0) {
          firstP = p;
          break;
        }
      }
      
      console.log('Found paragraph outside infobox:', firstP);
      
      if (firstP) {
        // Clean up the text (remove HTML tags, limit length)
        let text = firstP.textContent.trim();
        if (text.length > 200) {
          text = text.substring(0, 200) + '...';
        }
        
        // Update destination description
        document.getElementById('destDescription').textContent = text;
      } else {
        // No paragraph found, set a fallback description
        document.getElementById('destDescription').textContent = 'No description available.';
      }
      
      // Try to find and display an image
      const allImgs = tempDiv.querySelectorAll('img');
      console.log('All img elements:', allImgs);
      
      // Find the first image that's not within a messagebox or message-box element
      let imgToUse = null;
      for (const img of allImgs) {
        // Check if this image is within a messagebox or message-box element
        const messageboxParent = img.closest('.messagebox, .message-box, .message_box, .messagebox-container, .plainlinks, .above-header');
        if (!messageboxParent) {
          console.log('Found suitable image (not in message-box):', img);
          imgToUse = img;
          break;
        } else {
          console.log('Skipping image (in message-box):', img);
        }
      }
      
      if (imgToUse) {
        console.log('Selected image:', imgToUse);
        let imageUrl = imgToUse.src;
        console.log('Found image URL in HTML:', imageUrl);
        
        // Handle URL processing
        if (imageUrl.includes('localhost:8000')) {
          // Extract the path part after localhost:8000
          const urlParts = imageUrl.split('localhost:8000');
          if (urlParts.length > 1) {
            imageUrl = SITE + urlParts[1];
          }
        } else if (imageUrl.includes(window.location.hostname)) {
          // Replace references to our domain with the target domain
          console.log('Found current hostname in URL');
          console.log('window.location.hostname:', window.location.hostname);

          let hostname = window.location.hostname;
          if (hostname === 'localhost') {
            hostname = 'localhost:8000';
          }
          
          const urlParts = imageUrl.split(hostname);
          console.log('URL Parts:', urlParts);
          if (urlParts.length > 1) {
            imageUrl = `https://terraria.wiki.gg${urlParts[1]}`;
            console.log('After hostname replacement:', imageUrl);
          }
        } else if (imageUrl.startsWith('/')) {
          // Convert relative URL to absolute URL
          imageUrl = SITE + imageUrl;
        } else if (imageUrl.startsWith('file://')) {
          // Handle file:// URLs by converting to proper domain
          imageUrl = imageUrl.replace('file://', SITE);
        } else if (!imageUrl.startsWith('http')) {
          // Handle other relative URLs
          imageUrl = SITE + "/" + imageUrl;
        }
        // If it already starts with http, leave it as is
        
        console.log('Final image URL:', imageUrl);
        document.getElementById('destImageSrc').src = imageUrl;
        document.getElementById('destImage').classList.remove('hidden');
      } else {
        console.log('No suitable image found, hiding image');
        document.getElementById('destImage').classList.add('hidden');
      }
    } catch (err) {
      console.log('Could not fetch target preview:', err);
      document.getElementById('destTitle').textContent = 'Destination';
      document.getElementById('destDescription').textContent = 'Could not load destination info.';
      document.getElementById('destImage').classList.add('hidden');
    }
  }

  // Build a complete HTML doc for the iframe using the wiki's own headhtml bundle
  function buildSrcDoc({ html, head }) {
    // More careful script removal - keep CSS-related scripts but remove others
    const safeHead = head.replace(/<script\b[^>]*>(?!.*css|.*style)[\s\S]*?<\/script>/gi, '');
    
    // Ensure CSS links are properly formatted for the iframe
    let processedHead = safeHead.replace(/href="\/([^"]*)"/g, `href="${SITE}/$1"`);
    processedHead = processedHead.replace(/href='\/([^']*)'/g, `href='${SITE}/$1'`);
    
    return `<!doctype html>
<html class="client-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<base href="${SITE}/">
${processedHead}
<style>
/* Make links text-yellow-400, background dark grey, and text white */
.mw-parser-output a {
  color: #f59e0b !important;
}
.mediawiki {
  background-color: #1a1a1a !important;
  padding: 16px !important;
  border-radius: 8px !important;
  color: white !important;
}
.mw-parser-output {
  background-color: #1a1a1a !important;
  padding: 16px !important;
  border-radius: 8px !important;
  color: white !important;
}

.mw-body {
  background-color: #1a1a1a !important;
  padding: 16px !important;
  border-radius: 8px !important;
  color: white !important;
}

h1, h2, h3, h4, h5, h6 {
  color: white !important;
}

.thumb {
  background-color: #1a1a1a !important;
  padding: 16px !important;
  border-radius: 8px !important;
  color: white !important;
}

.toc {
  background-color: #1a1a1a !important;
  padding: 16px !important;
  border-radius: 8px !important;
  color: white !important;
}

</style>
</head>
<body class="mediawiki skin-vector skin-vector-legacy">
<div id="content" class="mw-body">
  <div id="mw-content-text" class="mw-body-content">
    ${html}  <!-- includes .mw-parser-output -->
  </div>
</div>
<script>
(function(){
  // Hydrate lazy/protocol-relative images
  function fixImages(root){
    root.querySelectorAll('img').forEach(function(img){
      var ds=img.getAttribute('data-src'), dss=img.getAttribute('data-srcset');
      if(ds && !img.src) img.src = ds;
      if(dss && !img.srcset) img.srcset = dss;
      if(img.src && img.src.startsWith('//')) img.src = 'https:' + img.src;
      if(img.srcset && img.srcset.includes('//')) img.srcset = img.srcset.replace(/(^|,\\s*)\\/\\//g,'$1https://');
      
      // Fix relative image URLs
      if(img.src && img.src.startsWith('/') && !img.src.startsWith('//')) {
        img.src = '${SITE}' + img.src;
      }
    });
  }
  fixImages(document);
  
  // Wait for CSS to load before showing content
  function waitForCSS() {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    var loadedCount = 0;
    var totalCount = links.length;
    
    if(totalCount === 0) {
      // No external CSS, show content immediately
      document.body.style.visibility = 'visible';
      return;
    }
    
    links.forEach(function(link) {
      if(link.sheet) {
        loadedCount++;
      } else {
        link.addEventListener('load', function() {
          loadedCount++;
          if(loadedCount >= totalCount) {
            document.body.style.visibility = 'visible';
          }
        });
        link.addEventListener('error', function() {
          loadedCount++;
          if(loadedCount >= totalCount) {
            document.body.style.visibility = 'visible';
          }
        });
      }
    });
    
    // Fallback: show content after 2 seconds regardless
    setTimeout(function() {
      document.body.style.visibility = 'visible';
    }, 2000);
  }
  
  // Hide content initially, show after CSS loads
  document.body.style.visibility = 'hidden';
  waitForCSS();

  // Intercept internal wiki links and send target title to parent
  document.addEventListener('click', function(e){
    var a = e.target.closest('a'); if(!a) return;
    var href = a.getAttribute('href')||'';
    
    // Handle anchor links (internal page navigation) - handle manually to avoid base href issues
    if(href.startsWith('#')) {
      console.log('Anchor link detected, handling manually');
      e.preventDefault();
      // Find the target element and scroll to it
      var targetId = href.substring(1);
      var targetElement = document.getElementById(targetId) || document.querySelector('[name="' + targetId + '"]');
      if(targetElement) {
        targetElement.scrollIntoView({ behavior: 'smooth' });
      }
      return; // Don't log or send message
    }
    
    // Log all non-anchor link attempts
    console.log('Link clicked:', href);
    parent.postMessage({type:'link-log', href:href}, '*');
    
    // Handle external links
    if (/^(https?:)?\\/\\//i.test(href) && !href.startsWith('${SITE}/wiki/') && !href.startsWith('/wiki/')) {
      console.log('External link detected, allowing normal navigation');
      return;
    }
    
    try{
      var u = new URL(href, '${SITE}');
      if(!u.pathname.startsWith('/wiki/')) {
        console.log('Non-wiki link detected, allowing normal navigation');
        return;
      }
      var title = u.searchParams.get('title') || decodeURIComponent(u.pathname.replace(/^\\/wiki\\//,'')).replace(/_/g,' ');
      if(!title) {
        console.log('No title found in link, allowing normal navigation');
        return;
      }
      console.log('Wiki navigation to:', title);
      e.preventDefault();
      parent.postMessage({type:'wiki-nav', title:title}, '*');
    }catch(err){
      console.log('Error parsing link:', err, 'allowing normal navigation');
    }
  }, true);
})();
</scr` + `ipt>
</body>
</html>`;
  }

  // Fetch + render a page into the iframe
  async function renderPage(title){
    const url = `${API}?action=parse&format=json&formatversion=2&redirects=1` +
                `&page=${encodeURIComponent(title)}&prop=text|headhtml&useskin=vector&origin=*`;
    const data = await j(url);

    const html  = data.parse.text;      // article HTML (.mw-parser-output inside)
    const head  = data.parse.headhtml;  // full skin/site TemplateStyles bundle
    const canon = data.parse.title;

    currentTitle = canon;
    if(!path.length) path=[canon];

    // Debug: Log the headhtml to see what CSS is being loaded
    console.log('Head HTML from API:', head);
    console.log('CSS links found:', (head.match(/<link[^>]*rel=["']stylesheet["'][^>]*>/gi) || []).length);

    document.getElementById('wikiFrame').srcdoc = buildSrcDoc({ html, head });
    
    // Update path history display
    updatePathHistory();

    // Win check
    if (targetTitle && currentTitle === targetTitle) {
      stopTimer();
      showWinModal();
    }
  }

  // Receive nav messages from iframe
  window.addEventListener('message', (ev)=>{
    if(!ev?.data) return;
    
    // Handle link logging
    if(ev.data.type === 'link-log') {
      console.log('Link attempted:', ev.data.href);
      // You can also display this in the UI if desired
      // For now, just logging to console
    }
    
    // Handle wiki navigation
    if(ev.data.type === 'wiki-nav') {
      const nextTitle = ev.data.title;
      clickCount++; document.getElementById('clicks').textContent = String(clickCount);
      path.push(nextTitle);
      renderPage(nextTitle);
    }
  });

  async function newRound({keepStart=false, keepTarget=false} = {}){
    stopTimer(); clickCount=0; path=[];
    document.getElementById('clicks').textContent='0';
    document.getElementById('timer').textContent='0:00';
    const loadingHtml = `<!doctype html>
<html>
<head>
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #f8fafc;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    color: #64748b;
  }
  
  .loading-container {
    text-align: center;
    padding: 2rem;
  }
  
  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid #e2e8f0;
    border-top: 3px solid #3b82f6;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  .loading-text {
    font-size: 1rem;
    font-weight: 500;
    color: #475569;
    margin: 0;
  }
  
  .loading-subtitle {
    font-size: 0.875rem;
    color: #94a3b8;
    margin: 0.5rem 0 0 0;
  }
</style>
</head>
<body>
  <div class="loading-container">
    <div class="spinner"></div>
    <p class="loading-text">Loading Warcraft Wiki...</p>
    <p class="loading-subtitle">Preparing your navigation challenge</p>
  </div>
</body>
</html>`;
    document.getElementById('wikiFrame').srcdoc = loadingHtml;
    // Get good titles (not too niche)
    if(!keepStart) {
      do { startTitle = await norm(await randTitle()); } while(!isGoodTitle(startTitle));
    }
    if(!keepTarget){
      do { 
        targetTitle = await norm(await randTitle()); 
      } while(targetTitle === startTitle || !isGoodTitle(targetTitle));
    }


    startTimer();
    await renderPage(startTitle);
    
    // Fetch and display target preview
    await fetchTargetPreview(targetTitle);
    
    // Update path history
    updatePathHistory();
  }

  // Win modal functions
  function showWinModal() {
    const modal = document.getElementById('winModal');
    const timeElapsed = Date.now() - startTimeMs;
    
    document.getElementById('winClicks').textContent = clickCount;
    document.getElementById('winTime').textContent = fmtTime(timeElapsed);
    
    // Display path steps
    const pathSteps = document.getElementById('winPathSteps');
    if (path.length > 0) {
      pathSteps.innerHTML = path.map((title, index) => {
        return `
          <div class="flex items-center">
            <span class="text-slate-500">${index + 1}.</span>
            <span class="ml-1">${title}</span>
          </div>
        `;
      }).join('');
    } else {
      pathSteps.innerHTML = '<p class="text-slate-500">No path recorded</p>';
    }
    
    modal.classList.remove('hidden');
  }
  
  function hideWinModal() {
    document.getElementById('winModal').classList.add('hidden');
  }
  
  function generateChallengeLink() {
    const url = new URL(window.location);
    url.searchParams.set('start', startTitle);
    url.searchParams.set('target', targetTitle);
    return url.toString();
  }
  
  function shareToTwitter() {
    const timeElapsed = Date.now() - startTimeMs;
    const text = `I completed the ${currentWikiConfig.name} Wiki Game from "${startTitle}" to "${targetTitle}" in ${clickCount} clicks! ðŸŽ® Can you beat my time?`;
    const url = generateChallengeLink();
    const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
    window.open(shareUrl, '_blank');
  }
  

  
  function copyChallengeLink() {
    const link = generateChallengeLink();
    navigator.clipboard.writeText(link).then(() => {
      // Update both copy buttons
      const btnCopyLink = document.getElementById('btnCopyLink');
      const btnCopyChallenge = document.getElementById('btnCopyChallenge');
      
      const originalTextLink = btnCopyLink.textContent;
      const originalTextChallenge = btnCopyChallenge.textContent;
      
      btnCopyLink.textContent = 'Copied!';
      btnCopyChallenge.textContent = 'Challenge Copied!';
      
      setTimeout(() => {
        btnCopyLink.textContent = originalTextLink;
        btnCopyChallenge.textContent = originalTextChallenge;
      }, 2000);
    });
  }
  
  // Event handlers
  document.getElementById('btnNew').onclick     = () => newRound();
  document.getElementById('btnCopyChallenge').onclick = copyChallengeLink;
  document.getElementById('btnCloseWin').onclick = () => { hideWinModal(); newRound(); };
  document.getElementById('btnShareTwitter').onclick = shareToTwitter;
  document.getElementById('btnCopyLink').onclick = copyChallengeLink;
  

  
  // Initialize with URL parameters if present
  const urlParams = getUrlParams();
  if (urlParams.start && urlParams.target) {
    startTitle = urlParams.start;
    targetTitle = urlParams.target;
    startTimer();
    renderPage(startTitle);
    fetchTargetPreview(targetTitle);
  } else {
    newRound();
  }
  </script>
</body>
</html>
